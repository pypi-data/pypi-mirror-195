# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['charmonium', 'charmonium.freeze']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'charmonium.freeze',
    'version': '0.7.1',
    'description': 'Injectively, deterministically maps arbitrary objects to hashable values',
    'long_description': '==========================\ncharmonium.freeze\n==========================\n\n.. image:: https://img.shields.io/pypi/v/charmonium.freeze\n   :alt: PyPI Package\n   :target: https://pypi.org/project/charmonium.freeze\n.. image:: https://img.shields.io/pypi/dm/charmonium.freeze\n   :alt: PyPI Downloads\n   :target: https://pypi.org/project/charmonium.freeze\n.. image:: https://img.shields.io/pypi/l/charmonium.freeze\n   :alt: License\n   :target: https://github.com/charmoniumQ/charmonium.freeze/blob/main/LICENSE\n.. image:: https://img.shields.io/pypi/pyversions/charmonium.freeze\n   :alt: Python Versions\n   :target: https://pypi.org/project/charmonium.freeze\n.. image:: https://img.shields.io/librariesio/sourcerank/pypi/charmonium.freeze\n   :alt: libraries.io sourcerank\n   :target: https://libraries.io/pypi/charmonium.freeze\n.. image:: https://img.shields.io/github/stars/charmoniumQ/charmonium.freeze?style=social\n   :alt: GitHub stars\n   :target: https://github.com/charmoniumQ/charmonium.freeze\n.. image:: https://github.com/charmoniumQ/charmonium.freeze/actions/workflows/main.yaml/badge.svg\n   :alt: CI status\n   :target: https://github.com/charmoniumQ/charmonium.freeze/actions/workflows/main.yaml\n.. image:: https://codecov.io/gh/charmoniumQ/charmonium.freeze/branch/main/graph/badge.svg?token=56A97FFTGZ\n   :alt: Code Coverage\n   :target: https://codecov.io/gh/charmoniumQ/charmonium.freeze\n.. image:: https://img.shields.io/github/last-commit/charmoniumQ/charmonium.cache\n   :alt: GitHub last commit\n   :target: https://github.com/charmoniumQ/charmonium.freeze/commits\n.. image:: http://www.mypy-lang.org/static/mypy_badge.svg\n   :target: https://mypy.readthedocs.io/en/stable/\n   :alt: Checked with Mypy\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/psf/black\n   :alt: Code style: black\n\nInjectively, deterministically maps arbitrary objects to hashable, immutable values\n\n\n----------\nQuickstart\n----------\n\nIf you don\'t have ``pip`` installed, see the `pip install guide`_.\n\n.. _`pip install guide`: https://pip.pypa.io/en/latest/installing/\n\n.. code-block:: console\n\n    $ pip install charmonium.freeze\n\nFor a related project, |charmonium.cache|_, I needed a function that\ndeterministically, injectively maps objects to hashable objects.\n\n- "Injectively" means ``freeze(a) == freeze(b)`` implies ``a == b``\n  (with the precondition that ``a`` and ``b`` are of the same type).\n\n- "Deterministically" means it should return the same value **across\n  subsequent process invocations** (with the same interpreter major\n  and minor version), unlike Python\'s |hash|_ function, which is not\n  deterministic between processes.\n\n- "Hashable" means one can call ``hash(...)`` on it. All hashable\n  values are immutable.\n\n.. |hash| replace:: ``hash``\n.. _`hash`: https://docs.python.org/3.8/reference/datamodel.html#object.__hash__\n.. |charmonium.cache| replace:: ``charmonium.cache``\n.. _`charmonium.cache`: https://github.com/charmoniumQ/charmonium.cache\n\nHave you ever felt like you wanted to "freeze" a list of arbitrary\ndata into a hashable value? Now you can.\n\n>>> obj = [1, 2, 3, {4, 5, 6}, object()]\n>>> hash(obj)\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nTypeError: unhashable type: \'list\'\n\n>>> from charmonium.freeze import freeze\n>>> from pprint import pprint\n>>> freeze(obj)\n(1, 2, 3, frozenset({4, 5, 6}), (b\'pickle\', b\'__newobj__\', ((b\'class\', \'builtins.object\'),)))\n\nIf you want to actually boil this down into a single integer, see\n|charmonium.determ_hash|_. This library\'s job is just to freeze the\nstate.\n\n.. |charmonium.determ_hash| replace:: ``charmonium.determ_hash``\n.. _`charmonium.determ_hash`: https://github.com/charmoniumQ/charmonium.determ_hash\n\nIt even works on custom types.\n\n>>> # Make a custom type\n>>> class Struct:\n...     def frobnicate(self):\n...         print(123)\n>>> s = Struct()\n>>> s.attr = 4\n>>> pprint(freeze(s))\n(b\'pickle\',\n b\'__newobj__\',\n ((b\'class\',\n   \'Struct\',\n   ((\'frobnicate\',\n     (b\'function\',\n      \'frobnicate\',\n      b\'t\\x00d\\x01\\x83\\x01\\x01\\x00d\\x00S\\x00\',\n      (None, 123))),),\n   b\'class\',\n   \'builtins.object\'),),\n (\'attr\', 4))\n\nAnd methods, functions, lambdas, etc.\n\n>>> pprint(freeze(lambda x: x + 123))\n(b\'function\', \'<lambda>\', b\'|\\x00d\\x01\\x17\\x00S\\x00\', (None, 123))\n>>> import functools\n>>> pprint(freeze(functools.partial(print, 123)))\n(b\'pickle\',\n b\'class\',\n \'partial\',\n ...,\n b\'class\',\n \'builtins.object\',\n (\'builtin func\', \'print\'),\n (\'builtin func\', \'print\'),\n (123,),\n (),\n None)\n>>> pprint(freeze(Struct.frobnicate))\n(b\'function\',\n \'frobnicate\',\n b\'t\\x00d\\x01\\x83\\x01\\x01\\x00d\\x00S\\x00\',\n (None, 123))\n>>> i = 0\n>>> def square_plus_i(x):\n...     # Value of global variable will be included in the function\'s frozen state.\n...     return x**2 + i\n... \n>>> pprint(freeze(square_plus_i))\n(b\'function\',\n \'square_plus_i\',\n b\'|\\x00d\\x01\\x13\\x00t\\x00\\x17\\x00S\\x00\',\n (None, 2),\n (\'i\', 0))\n\nIf the source code of ``square_plus_i`` changes between successive invocations,\nthen the ``freeze`` value will change. This is useful for caching unchanged\nfunctions.\n\n-------------\nSpecial cases\n-------------\n\n- ``freeze`` on functions returns their bytecode, constants, and\n  closure-vars. The remarkable thing is that this is true across subsequent\n  invocations of the same process. If the user edits the script and changes the\n  function, then it\'s ``freeze`` will change too.\n\n  ::\n\n    (freeze(f) == freeze(g)) implies (for all x, f(x) == g(x))\n\n- ``freeze`` on an object returns the data that used in the `pickle\n  protocol`_. This makes ``freeze`` work correctly on most user-defined\n  types. However, there can still be special cases: ``pickle`` may incorporate\n  non-deterministic values. In this case, there are two remedies:\n\n  - If you can tweak the definition of the class, add a method called\n    ``__getfrozenstate__`` which returns a deterministic snapshot of the\n    state. This takes precedence over the Pickle protocol, if it is defined.\n\n    >>> class Struct:\n    ...     pass\n    >>> s = Struct()\n    >>> s.attr = 4\n    >>> pprint(freeze(s))\n    (b\'pickle\',\n     b\'__newobj__\',\n     ((b\'class\', \'Struct\', (), b\'class\', \'builtins.object\'),),\n     (\'attr\', 4))\n    >>> # which is based on the Pickle protocol\'s definition of `__reduce__`:\n    >>> pprint(s.__reduce__())\n    (<function _reconstructor at 0x...>,\n     (<class \'__main__.Struct\'>, <class \'object\'>, None),\n     {\'attr\': 4})\n\n\n  - Otherwise, you can ignore certain attributes by creating a\n    ``Config`` object or modifying the ``global_config`` object. See\n    the source code of ``charmonium/freeze/config.py`` for more\n    details.\n\n    >>> from charmonium.freeze import freeze, Config\n    >>> class Test:\n    ...     deterministic_val = 3\n    ...     nondeterministic_val = 4\n    ... \n    >>> config = Config()\n    >>> config.ignore_attributes.add(("__main__", "Test", "nondeterministic_val"))\n    >>> freeze(Test(), config)\n    (b\'pickle\', b\'__newobj__\', ((b\'class\', \'Test\', ((\'deterministic_val\', 3),), b\'class\', \'builtins.object\'),))\n\n    Note that ``nondeterministic_val`` is not present in the frozen object.\n\n\n  - If you cannot tweak the definition of the class or monkeypatch a\n    ``__getfrozenstate__`` method, you can still register `single dispatch\n    handler`_ for that type:\n\n    >>> from typing import Hashable, Optional, Dict, Tuple\n    >>> from charmonium.freeze import _freeze_dispatch, _freeze\n    >>> @_freeze_dispatch.register(Test)\n    ... def _(\n    ...         obj: Test,\n    ...         config: Config,\n    ...         tabu: Dict[int, Tuple[int, int]],\n    ...         level: int,\n    ...         index: int,\n    ...     ) -> Tuple[Hashable, bool, Optional[int]]:\n    ...     # Type annotations are optional.\n    ...     # I have included them here for clarity.\n    ... \n    ...     # `tabu` is for object cycle detection.\n    ...     # It is handled for you.\n    ... \n    ...     # `level` is for logging and recursion limits.\n    ...     level = level + 1\n    ... \n    ...     # Freeze should depend only on deterministic values.\n    ...     if isinstance(obj.deterministic_val, int):\n    ...         return (\n    ...             obj.deterministic_val,\n    ...             # The underlying frozen value. It should be hashable.\n    ...             # It is usually made up of frozenset (replaces dict, set, and class attrs)\n    ...             # and tuple (replaces list).\n    ... \n    ...             False,\n    ...             # Whether the obj is immutable\n    ...             # If the obj is immutable, it\'s frozen value need not be recomputed every time.\n    ...             # This is handled for you.\n    ... \n    ...             None,\n    ...             # The depth of references contained here or None\n    ...             # Currently, this doesn\'t do anything.\n    ...         )\n    ...     else:\n    ...         # If the underlying instance variable is not hashable, we can use recursion to help.\n    ...         # Call `_freeze` instead of `freeze` to recurse with `tabu` and `level`.\n    ...         return _freeze(obj.deterministic_val, tabu, level, 0)\n    ... \n    >>> freeze(Test())\n    3\n\n- Note that as of Python 3.7, dictionaries "remember" their insertion order. As such,\n\n  >>> freeze({"a": 1, "b": 2})\n  ((\'a\', 1), (\'b\', 2))\n  >>> freeze({"b": 2, "a": 1})\n  ((\'b\', 2), (\'a\', 1))\n\n  This behavior is controllable by ``Config.ignore_dict_order``, which emits a ``frozenset`` of pairs.\n\n  >>> config = Config(ignore_dict_order=True)\n  >>> freeze({"b": 2, "a": 1}, config) == freeze({"a": 1, "b": 2}, config)\n  True\n\n.. _`pickle protocol`: https://docs.python.org/3/library/pickle.html#pickling-class-instances\n.. _`single dispatch handler`: https://docs.python.org/3/library/functools.html#functools.singledispatch\n\n----------\nDeveloping\n----------\n\nSee `CONTRIBUTING.md`_ for instructions on setting up a development environment.\n\n.. _`CONTRIBUTING.md`: https://github.com/charmoniumQ/charmonium.freeze/tree/main/CONTRIBUTING.md\n\n---------\nDebugging\n---------\n\nUse the following lines to see how ``freeze`` decomposes an object into\nprimitive values.\n\n.. code:: python\n\n    import logging, os\n    logger = logging.getLogger("charmonium.freeze")\n    logger.setLevel(logging.DEBUG)\n    fh = logging.FileHandler("freeze.log")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(logging.Formatter("%(message)s"))\n    logger.addHandler(fh)\n    logger.debug("Program %d", os.getpid())\n\n    i = 0\n    def square_plus_i(x):\n        # Value of global variable will be included in the function\'s frozen state.\n        return x**2 + i\n\n    from charmonium.freeze import freeze\n    freeze(square_plus_i)\n\n\nThis produces a log such as in ``freeze.log``:\n\n::\n\n    freeze begin <function square_plus_i at 0x7f9228bff550>\n     function <function square_plus_i at 0x7f9228bff550>\n      tuple ((\'code\', <code object square_plus_i at 0x7f9228c6cf50, file "/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py", line 2>), \'closure globals\', {\'i\': 0})\n       tuple (\'code\', <code object square_plus_i at 0x7f9228c6cf50, file "/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py", line 2>)\n        \'code\'\n        code <code object square_plus_i at 0x7f9228c6cf50, file "/tmp/ipython_edit_303agyiz/ipython_edit_rez33yf_.py", line 2>\n         tuple (None, 2)\n          None\n          2\n         b\'|\\x00d\\x01\\x13\\x00t\\x00\\x17\\x00S\\x00\'\n       \'closure globals\'\n       dict {\'i\': 0}\n        \'i\'\n        0\n    freeze end\n\nI do this to find the differences between subsequent runs:\n\n.. code:: shell\n\n    $ python code.py\n    $ mv freeze.log freeze.0.log\n\n    $ python code.py\n    $ mv freeze.log freeze.1.log\n\n    $ sed -i \'s/at 0x[0-9a-f]*//g\' freeze.*.log\n    # This removes pointer values that appear in the `repr(...)`.\n\n    $ meld freeze.0.log freeze.1.log\n    # Alternatively, use `icdiff` or `diff -u1`.\n\nTODO\n----\n\n- ☐ Correctness\n\n  - ☑ Test hashing sets with different orders. Assert tests fail.\n  - ☑ Test hashing dicts with different orders. Assert tests fail.\n  - ☑ Don\'t include properties in hash.\n  - ☑ Test that freeze of an object includes freeze of its instance methods.\n  - ☑ Test functions with minor changes.\n  - ☑ Test set/dict with diff hash.\n  - ☑ Test obj with slots.\n  - ☑ Test hash for objects and classes more carefully.\n  - ☑ Improve test coverage.\n  - ☑ Investigate when modules are assumed constant.\n  - ☐ Detect if a module/package has a version. If present, use that. Else, use each attribute.\n  - ☐ Support closures which include ``import x`` and ``from x import y``\n\n- ☑ API\n\n  - ☑ Use user-customizable multidispatch.\n  - ☑ Bring hash into separate package.\n  - ☑ Make it easier to register a freeze method for a type.\n  - ☑ Encapsulate global config into object.\n  - ☑ Make freeze object-oriented with a module-level instance, like ``random.random`` and ``random.Random``.\n    - This makes it easier for different callers to have their own configuration options.\n  - ☐ Add an option which returns a single 128-bit int instead of a structured object after a certain depth. This is what ``charmonium.determ_hash`` does. Use this configuration in ``charmonium.cache``.\n  - ☐ Move "get call graph" into its own package.\n  - ☐ Document configuration options.\n  - ☐ Document ``summarize_diff`` and ``iterate_diffs``.\n  - ☐ Have an API for ignoring modules in ``requirements.txt`` or ``pyproject.toml``, and just tracking them by version.\n  - ☐ Config object should cascade with ``with config.set(a=b)``\n  - ☐ Bring hash into the same package, by having ``config.hash_only``. When ``True``, we return a single int, else a representation of the original object.\n    - I don\'t know. That makes it impossible to use the cache and memo. You don\'t know the hash of each thing.\n  - ☐ Bring object-diff into separate package.xo\n\n- ☑ Make ``freeze`` handle more types:\n\n  - ☑ Module: freeze by name.\n  - ☑ Objects: include the source-code of methods.\n  - ☑ C extensions. freeze by name, like module\n  - ☑ Methods\n  - ☑ fastpath for numpy arrays\n  - ☑ ``tqdm``\n  - ☑ ``numpy.int64(1234)``\n  - ☑ Pandas dataframe\n  - ☑ Catch Pickle TypeError\n  - ☑ Catch Pickle ImportError\n\n- ☐ Performance\n\n  - ☑ Memoize the hash of immutable data:\n    - If function contains no locals or globals except other immutables, it is immutable.\n    - If a collection is immutable and contains only immutables, it is immutable.\n  - ☐ Consider deprecating ``combine_frozen``.\n  - ☑ Make performance benchmarks.\n',
    'author': 'Samuel Grayson',
    'author_email': 'sam+dev@samgrayson.me',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/charmoniumQ/charmonium.freeze',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)

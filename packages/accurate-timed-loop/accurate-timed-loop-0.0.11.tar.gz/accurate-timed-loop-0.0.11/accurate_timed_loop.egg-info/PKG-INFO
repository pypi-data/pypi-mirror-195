Metadata-Version: 2.1
Name: accurate-timed-loop
Version: 0.0.11
Summary: Accurate timed loop
Home-page: https://bitbucket.org/arrizza-public/accurate-timed-loopsrc/master
Download-URL: https://bitbucket.org/arrizza-public/accurate-timed-loop/get/master.zip
Author: JA
Author-email: cppgent0@gmail.com
License: MIT
Keywords: accurate loop,utility
Classifier: Development Status :: 3 - Alpha
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: Topic :: Utilities
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.9
Description-Content-Type: text/markdown
License-File: LICENSE.txt

# Accurate Timed Loop #

This is a python module that provide a way to have an acccurate timed loop.

For example if you need to do an activity every 250ms +/-3ms, this loop will do that.

### Sample code ###

see sample.py for a full example

```python
import accurate_timed_loop

loop_delay = 0.250  # seconds
total_wait = 25.0  # seconds
for elapsed, start_time in accurate_timed_loop.accurate_wait(total_wait, loop_delay):
  # ... do task every 250 mS
  pass
```

### Accuracy and Limitations ###

The sample.py does testing and shows that on Windows MSYS2 the average error is roughly 8mS in a 250mS loop

```text
      expected    elapsed  diff1(ms)  actual(s)  diff2(ms)
  1   0.000000   0.000000      0.000   0.000000      0.000
<snip>
100  24.750000  24.751729      1.729  24.751729      1.729
101  25.000000  25.001656      1.656  25.001656      1.656


Stats:
count   : 101 loops
Range   : 0.000 to 48.234 mS
Stddev  :      5.885 mS
Average :     11.849 mS
```

This value is specific to Windows and to the PC that it is running on.

To make it more accurate for your PC and OS use the fixed_adjustment parameter. Set it to the
average error (in seconds).

```python
import accurate_timed_loop

loop_delay = 0.250  # seconds
total_wait = 25.0  # seconds
adj = 0.009500  # win mys2
for elapsed, start_time in accurate_timed_loop.accurate_wait(total_wait, loop_delay, fixed_adjustment=adj):
  # ... do task every 250 mS
  pass
```

Re-run this several times, tweak the fixed adjustment:

* if the Average error > 0, add it to the adjustment
* if the Average error < 0, subtracct it from the adjustment
* repeat several time to ensure a consistent, low Average error

```text
      expected    elapsed  diff1(ms)  actual(s)  diff2(ms)
  1   0.000000   0.000000      0.000   0.000000      0.000
 <snip>
101  25.000000  25.004485      4.485  25.004485      4.485


Stats:
count   : 101 loops
Range   : -8.930 to 29.270 mS
Stddev  :      5.760 mS
Average :      0.098 mS
```

Limitations:

* there is NO guarantee that the average error will always be that low or that consistent

```text
# === first run:
Stats:
count   : 101 loops
Range   : -8.930 to 29.270 mS
Stddev  :      5.760 mS
Average :      0.098 m

# === second run:
Stats:
count   : 102 loops
Range   : -8.437 to 28.499 mS
Stddev  :      5.576 mS
Average :      0.827 mS

# === third run:
Stats:
count   : 102 loops
Range   : -9.081 to 21.172 mS
Stddev  :      4.792 mS
Average :      0.100 mS

# === fourth run:
Stats:
count   : 102 loops
Range   : -8.839 to 25.438 mS
Stddev  :      5.018 mS
Average :      0.811 mS

# === fifth run:
Stats:
count   : 102 loops
Range   : -7.452 to 10.125 mS
Stddev  :      4.296 mS
Average :      0.609 mS
```

* the incoming "elapsed" parameter will not be after your expected delay.
  For example these two came in at 24.749 seconds instead of 24.750 and
  at 24.999 seconds instead of 25.000 seconds

```text
      expected    elapsed  diff1(ms)  actual(s)  diff2(ms)
100  24.750000  24.749573     -0.427  24.749573     -0.427
101  25.000000  24.999601     -0.399  24.999601     -0.399
```

// Operator terminals.
UND: "undef"
NEG: "not"
ADD: "+"
SUB: "-"
DIV: "/"
MOD: "\\"
MUL: "*"
NEQ: "!="
EQQ: "="
LES: "<"
GRT: ">"
LEQ: "<="
GEQ: ">="

// Operators.
OP: ADD
  | SUB
  | DIV
  | MOD
  | MUL
  | EQQ
  | NEQ
  | LES
  | GRT
  | LEQ
  | GEQ

// Comparison operators.
CMP_OP: EQQ
      | NEQ
      | LES
      | GRT
      | LEQ
      | GEQ

frac: REAL "/" REAL
prob: frac | REAL

// Constants.
WORD: /[a-z]\w*/
// Variables.
VAR: /[A-Z]\w*/

// Boolean type.
BOOL: (/true/i | /false/i)
// Null type.
NULL: (/null/i | /none/i)

// URL.
URL: /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/
// Local data path.
LOCAL_DATA: /(?:\/?[a-zA-Z\d\.\-_]+|(?:\\ ))+/
// Python function identifier.
PY_FUNC: /[a-zA-Z_][a-zA-Z0-9_]*/
// Local network path.
LOCAL_NET: /(?:[\w\d.\-_\/]+|(?:\\ ))+/
// Github repo network path.
GITHUB: /[A-Za-z\d](?:[A-Za-z\d]|-(?=[A-Za-z\d])){0,38}\/[a-zA-Z0-9\-_.]{1,100}/
// Path.
path: "\"" (LOCAL_DATA | URL) "\""

EXPAND: "+"
LEARN:  "?"
CONST:  "!"

// Set.
set: "{" (ID | WORD) ("," (ID | WORD))+ "}"

// Atom.
_atom: WORD
// Interval.
interval: (ID | WORD) ".." (ID | WORD)
// Predicate.
_ground: (_atom | grpred)
_nground: (_atom | pred)
grpred: WORD "(" (_ground | ID | interval) ("," (_ground | ID | interval))* ")"
pred: WORD "(" (_nground | ID | interval | VAR) ("," (_nground | ID | interval | VAR))* ")"
// Literal.
lit: NEG* _nground
grlit: NEG* _ground

// Aggregate constraints.
!aggr: (/[0-9]+/ CMP_OP)? ("#" ("sum" | "count" | "sum+" | "min" | "max"))? "{" /[^\}]+/ "}" (CMP_OP /[0-9]+/)? "."

// Fact.
fact: _ground "."
// Probabilistic fact.
pfact: prob "::" _ground "."
lpfact: prob? "?" "::" _ground "."
// Credal fact.
cfact: "[" prob "," prob "]" "::" _ground "."
_fact: fact | pfact | lpfact | cfact

// Head of a rule.
head: _nground (("," | ";") _nground)*
ohead: _nground
// Body of a rule.
body: (lit | bop) ("," (lit | bop))*
// Rule.
rule: head ":-" body "."
// Probabilistic rule.
prule: prob (EXPAND? LEARN? | LEARN? EXPAND?) "::" ohead ":-" body "."
_rule: prule | rule

// Annotated disjunction head.
ad_head{arg}: prob "::" arg (";" prob "::" arg)+
// Learnable annotated disjunction head.
lad_head{arg}: prob? "?" "::" arg (";" prob? "?" "::" arg)+
// Annotated disjunctions.
ad: (ad_head{_ground} | lad_head{_ground}) "."
adr: (ad_head{_nground} | lad_head{_nground}) ":-" body "."
_ad: ad | adr

// Data special rule.
test: "test" "(" (path | ("@" PY_FUNC)) ")"
train: "train" "(" (path | ("@" PY_FUNC)) ")"
data: WORD "(" (WORD | ID) ")" "~" test ("," train)? "."
// Torch block.
torch: "#torch" /(?:.|\n)+?(?=\#end\.)/ "#end."
// PyTorch hub.
hub: "@" PY_FUNC ("on" (("\"" LOCAL_NET "\"" ("at" "\"local\"")?) | ("\"" GITHUB "\"" "at" "\"github\"")))?
// Optimizer parameters.
_param: WORD "=" (REAL | BOOL | NULL)
// Sequence of parameters.
params: _param ("," _param)*
// Neural fact.
nrule: (LEARN | CONST) "::" WORD "(" VAR ")" "as" hub ("with" params)? ":-" lit ("," lit)* "."
// Neural annotated disjunction.
nad: (LEARN | CONST) "::" WORD "(" VAR "," set ")" "as" hub ("with" params)? ":-" lit ("," lit)* "."
_neural: nrule | nad

// Constraint.
constraint: ":-" body "."

// Binary operation.
bop: ((ID | VAR | bop) OP (ID | VAR | bop)) | (VAR EQQ interval)

// Query.
qelement: (NEG | UND)? (WORD | grpred)
interp: qelement ("," qelement)*
query: "#query(" interp ("|" interp)? ")" "."?

// Constant definition.
constdef: "#const" WORD "=" ID "."

plp: (constdef | _fact | _rule | _ad | _neural | data | torch | constraint | query | aggr)*

COMMENT: "%" /[^\n]*/ NEWLINE

%import common.WORD -> NAME
%import common.INT -> ID
%import common.NUMBER -> REAL
%import common.NEWLINE -> NEWLINE
%import common.WS

%ignore WS
%ignore COMMENT

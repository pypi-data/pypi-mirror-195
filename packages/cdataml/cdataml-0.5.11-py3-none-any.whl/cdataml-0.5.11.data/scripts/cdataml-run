#!python

"""
cdataml-run
"""

import cdataml
import os
import sys
import pandas as pd
import argparse
from pathlib import Path
import numpy as np
import cv2 as cv
from importlib_resources import files

parser = argparse.ArgumentParser(add_help=True, formatter_class=argparse.RawDescriptionHelpFormatter, description = "test-script")
parser.add_argument("-s", "--source_folder", help="folder containing images to analyse", type=str, default=None)
parser.add_argument("-f", "--file", help="cdata csv file to update. created if does not exist.", type=str, default=None)
parser.add_argument("-n", "--num_spots", help="the number of spots per leaf. must be consistent across all leaves", type=int, default=8)
args = parser.parse_args()

if not os.path.exists(args.source_folder):
    sys.exit(f"ERROR: source folder {args.source_folder} does not exist")

if not os.path.exists(args.file):
    print(f"NOTE: input file {args.file} does not exist. creating ...")
    cdata = pd.DataFrame(columns=["img", "maxrow", "maxcol", "row", "col", "pos", "score", "x1", "x2", "y1", "y2"])
    cdata.to_csv(args.file, index=False)
else:
    if not args.file.endswith('.csv'):
        sys.exit(f"ERROR: input file {args.file} is not a CSV file")
    cdata = pd.read_csv(args.file)
    if not list(cdata.columns.values) == ["img", "maxrow", "maxcol", "row", "col", "pos", "score", "x1", "x2", "y1", "y2"]:
        sys.exit(f"ERROR: input file {args.file} contains incorrect column names")

if args.num_spots <= 0:
    sys.exit("ERROR: number of spots per leaf cannot be less than or equal to zero")

def _load_key():
    print("Loading Key")
    data_path = files('cdataml').joinpath('lesion_score_key.tif')
    print(data_path)
    key = cv.imread(cv.samples.findFile(str(data_path)))
    cv.imshow("Key", key)
    cv.setWindowProperty("Key", cv.WND_PROP_TOPMOST, 1)
    cv.waitKey(0)
    return(key)

def _initialise_metadata(files, df):
    if len(df) == 0: # If New Cdata.csv File, Initialise First Row
        initial_metadata = cdataml.cdametadata.CDAMetadata(
        img = files[0],
        maxrow = None,
        maxcol = None,
        row = 1,
        col = 1,
        pos = 1
        )
    else: # Else Load Last Available Row
        last_row = df.iloc[-1]
        initial_metadata = cdataml.cdametadata.CDAMetadata(
        img = last_row[0],
        maxrow = last_row[1],
        maxcol = last_row[2],
        row = last_row[3],
        col = last_row[4],
        pos = last_row[5]
        )
    return initial_metadata

def _construct_display(ref, scale):
    img = cv.imread(cv.samples.findFile(ref.iloc[0]["img"]))

    # Appending the metadata to the top of the image
    meta_bar = np.full((200, img.shape[1],3), 255, dtype=np.uint8)
    with_meta = np.concatenate((meta_bar, img))
    meta_text = "".join(str(e) for e in ["record data for the following CDA: ", "Img:", os.path.basename(ref.iloc[0]["img"]), ", Row:", ref.iloc[0]["row"], ", Col:", ref.iloc[0]["col"], ", Pos:", ref.iloc[0]["pos"]])
    cv.putText(img = with_meta, text = meta_text, org = (50, 160), fontFace=cv.FONT_HERSHEY_PLAIN, fontScale=8, color=(0, 0, 0),thickness=8)


    # Appending the score key to the bottom of the image
    key = _load_key()
    key_scale = key.shape[1] / imgwithmetadata.shape[1]
    key_dims = (int(key.shape[1]/key_scale), int(key.shape[0]/key_scale))
    scaled_key = cv.resize(key, key_dims)
    with_meta = np.concatenate((with_meta, scaled_key))

    # Scaling the image otherwise it takes a long time to load
    dim = (int(with_meta.shape[1]*scale), int(with_meta.shape[0]*scale))
    img_scaled = cv.resize(with_meta, dim)

    return img_scaled

def _save_and_quit(df, file_path):
    print("Saving and Quitting")
    # Move Previous Version to Backup and Save Existing Version
    os.rename(file_path, os.path.join(os.path.dirname(file_path) + "backup_" + os.path.basename(file_path)))
    df.to_csv(file_path, index = False)
    # Close all OpenCV Windows and Quit
    cv.destroyAllWindows()
    sys.exit()

def _skip_spots(num_to_skip, current_metadata):
    # Assumes end of image will update metadata to first of next img.
    print("Skipping")
    # Update the metadata either once if single spot skipped, or to end of leaf if whole leaf skipped
    end_of_img = False
    for skip in range(0, num_to_skip):
        if current_metadata.pos == args.num_spots:
            if current_metadata.row == current_metadata.maxrow and current_metadata.col == current_metadata.maxcol: # End of Leaf
                end_of_img = True
                break
            else:
                break
        elif not num_to_skip == 1:
            current_metadata._update(args.num_spots) # Next metadata
    return current_metadata, end_of_img # If final metadata End of Img

def _next_img(end_of_img, current_metadata, image_files):
    if end_of_img == False:
        return False
    else:
        if current_metadata.img == image_files[-1]: # Check if current img is final img
            print("End of Data")
            _save_and_quit(df, args.file)
        else: # Else Move to Next Image
            return True

def record_cdata(source_folder, df, num_spots):
    # Find TIF Files in Source Folder
    image_files = [str(file.resolve()) for file in Path(source_folder).iterdir() if
                   file.is_file() and not file.name.startswith(".") and
                   file.name.endswith(".tif")]

    # Initialise CDAMetadata Object
    current_metadata = _initialise_metadata(image_files, df)
    current_metadata, end_of_img = current_metadata._update(args.num_spots)
    if _next_img(end_of_img, current_metadata, image_files) == True:
        current_metadata.img = image_files[image_files.index(current_metadata.img)+1]



    # Loop through image files, starting at current_metadata.image
    for img_num in range(image_files.index(current_metadata.img), len(image_files)):
        img = image_files[img_num]
        # Record the maxrow and maxcol values
        current_metadata.img = img
        if current_metadata.maxrow == None or current_metadata.maxcol == None:
            dims_input = cdataml.datainput._record_dims(img)
            if dims_input == None: # If dims_input None, Exit
                _save_and_quit(df, args.file)
            else: # If dims_input Valid Int, Store
                current_metadata.maxrow, current_metadata.maxcol = dims_input

        end_of_img = False
        while end_of_img == False:
            skipped = False
            # Construct the image with metadata and key to be displayed
            display_img = _construct_display(current_metadata._make_pandas(), 0.25)

            # Recording Coordinate Input (uses SelectROI)
            current_metadata.x1, current_metadata.x2, current_metadata.y1, current_metadata.y2 = cdataml.datainput._input_coords(display_img, 0.25)

            # Recording Score Input or Skipping Spots
            score_input = cdataml.datainput._input_score(display_img)
            if score_input == 'l': # If Score Input 'l', Skip Leaf
                current_metadata, end_of_img = _skip_spots(args.num_spots, current_metadata)
                skipped = True
            elif score_input == 's': # If Score Input 's', Skip Spot
                current_metadata, end_of_img = _skip_spots(1, current_metadata)
                skipped = True
            elif score_input == None: # If Score Input None, Exit
                _save_and_quit(df, args.file)
            else: # If Score Input Valid Int, Store
                current_metadata.score = score_input


            # Append Score and Coordinate Data to DataFrame
            if skipped == False:
                print("Adding Entered Data to Table")
                df = pd.concat([df, current_metadata._make_pandas()], ignore_index=True)

            # Update Metadata
            prev_img = current_metadata.img
            print(current_metadata)
            current_metadata, end_of_img = current_metadata._update(args.num_spots)
            if _next_img(end_of_img, current_metadata, image_files) == True:
                break


if __name__ == '__main__':
    record_cdata(args.source_folder, cdata, args.num_spots)
